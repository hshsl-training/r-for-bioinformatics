[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R for Bioinformatics",
    "section": "",
    "text": "This hands-on workshop is designed for researchers who are already familiar with R and the tidyverse and want to explore how R can be used for common bioinformatics tasks. We’ll introduce tools and workflows for working with biological sequence data—such as retrieving DNA sequences, aligning them, and building phylogenetic trees—using packages from the Bioconductor project. Whether you’re working with genomics, transcriptomics, or other biological datasets, this session will help you get started with the bioinformatics capabilities of R.\nAfter this session, participants will be able to:\n\nWork with biological data in R using specialized packages\nExplore and manipulate common types of bioinformatics data\nApply tidyverse skills to bioinformatics workflows\nBecome familiar with widely used bioinformatics packages and how to find them"
  },
  {
    "objectID": "index.html#course-description",
    "href": "index.html#course-description",
    "title": "R for Bioinformatics",
    "section": "",
    "text": "This hands-on workshop is designed for researchers who are already familiar with R and the tidyverse and want to explore how R can be used for common bioinformatics tasks. We’ll introduce tools and workflows for working with biological sequence data—such as retrieving DNA sequences, aligning them, and building phylogenetic trees—using packages from the Bioconductor project. Whether you’re working with genomics, transcriptomics, or other biological datasets, this session will help you get started with the bioinformatics capabilities of R.\nAfter this session, participants will be able to:\n\nWork with biological data in R using specialized packages\nExplore and manipulate common types of bioinformatics data\nApply tidyverse skills to bioinformatics workflows\nBecome familiar with widely used bioinformatics packages and how to find them"
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "R for Bioinformatics",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nMany thanks to Jean-Paul Courneya for thoughtful feedback and testing that helped shaped this lesson."
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "R for Bioinformatics",
    "section": "License",
    "text": "License\nThis work is licensed under a Creative Commons Attribution 4.0 International License (CC BY)"
  },
  {
    "objectID": "03-msa.html",
    "href": "03-msa.html",
    "title": "Building a Bioinformatics Workflow",
    "section": "",
    "text": "Become familiar with specialized R data structures\nBe able to interpret NCBI accession numbers\nUse R to align sequences\nUse R to draw phylogenetic trees\n\nIn this section, we will work through an entire workflow for finding protein sequences, aligning them, and using that alignment to create a phylogenetic tree."
  },
  {
    "objectID": "03-msa.html#learning-objectives",
    "href": "03-msa.html#learning-objectives",
    "title": "Building a Bioinformatics Workflow",
    "section": "",
    "text": "Become familiar with specialized R data structures\nBe able to interpret NCBI accession numbers\nUse R to align sequences\nUse R to draw phylogenetic trees\n\nIn this section, we will work through an entire workflow for finding protein sequences, aligning them, and using that alignment to create a phylogenetic tree."
  },
  {
    "objectID": "03-msa.html#getting-protein-sequences-with-rentrez",
    "href": "03-msa.html#getting-protein-sequences-with-rentrez",
    "title": "Building a Bioinformatics Workflow",
    "section": "Getting protein sequences with rentrez",
    "text": "Getting protein sequences with rentrez\nWe previously looked for the nucleotide sequence for the human TP53 gene. Our goal in this lesson will be to find orthologs of that gene. An ortholog is a gene in different species that evolved from a common ancestral gene through speciation and typically retains the same function.\nFirst, let’s build our query to use in entrez_search(). You can write the query directly in the term argument of the function, but sometimes it can be cleaner to create a separate object to store your query. Especially if it is a more complicated one. We’re going to use the gene homologene filter to look for our homologous sequences.\n\nquery &lt;- \"TP53[gene name] AND gene homologene[filter]\"\n\nNow let’s add that query to our search\n\ntp53_homologs &lt;- entrez_search(db=\"gene\", \n                               term = query)\n\nOur search returned 9 ids for homologous genes\n\ntp53_homologs$ids\n\n[1] \"7157\"   \"22059\"  \"24842\"  \"30590\"  \"403869\" \"281542\" \"716170\" \"431679\"\n[9] \"455214\"\n\n\nBefore fetching any sequences, let’s take a closer look at some metadata for these records with the function entrez_summary()\n\nsearch_summ &lt;- entrez_summary(db=\"gene\",\n                              id=tp53_homologs$ids)\n\nThe summary object is another list, with an element for each id, and each of those elements contains metadata fields, some of which have more nested metadata fields. The original records are stored in Entrez as XML files. XML is a hierarchical data structure, and in R those kinds of structures are represented as lists.\nTo make it simpler to navigate this nested structure, we can use the function extract_from_esummary() to pull out one or more fields to look at.\n\nextract &lt;- \n  extract_from_esummary(search_summ, \n                        elements = \"organism\", \n                        simplify = TRUE)\n\nThe extract returns a matrix, another important R data structure. With a little work, we can turn the matrix into a more familiar looking data frame. Matrices are two dimensional like data frames (i.e. they have columns and rows), but the data must be homogenous (of the same type). Note that a matrix has named columns and rows.\nFirst we can transpose the columns and rows with t(), so that the fields are columns and the rows are records.\n\nt_extract &lt;- t(extract)\n\nNow we can try to coerce this transposed matrix to a tibble with the as_tibble function. This still maintains the uids as rownames, so we can use the rownames= argument to put those rownames in a new column called uid. We now have a tibble of list-columns. Most of the columns are actually lists. We can use unnest() to turn them into regular data frame columns.\n\ndf &lt;- as_tibble(t_extract, rownames = \"uid\") %&gt;% \n  unnest(cols = everything())\n\nLet’s use entrez_link() to find links from these ids in the Protein database which contains amino acid sequences.\n\nprotein_links &lt;- entrez_link(dbfrom = \"gene\", \n                             id = df$uid, \n                             db=\"protein\")\n\nThis found 58 sequences in the protein_refseq collection. Let’s use entrez_summary again to get an overview of what these sequences are.\n\nlink_summary &lt;- entrez_summary(db=\"protein\",\n                               id=protein_links$links$gene_protein_refseq)\n\nAnd extract_from_esummary() to view these elements more easily.\n\nlink_extract &lt;- \n  extract_from_esummary(link_summary,\n                        elements = c(\"uid\", \"caption\", \"slen\", \"organism\"))\n\n\nlink_df &lt;- as_tibble(t(link_extract)) %&gt;% \n  unnest(cols = everything())\n\nWe see now that our search returned multiple protein sequences for some species. For our analysis, we want just one sequence per species. So we can group our data frame by organism, and then sort by the caption (accession number) and sequence length (slen). Finally we use the slice() function to pull out just the first row of each group.\n\n\n\n\n\n\nA note about RefSeq accession numbers\n\n\n\nThe RefSeq accession number naming scheme from NCBI uses prefixes to indicate the type and status of the sequence record. For example:\n\n\n\n\n\n\n\n\n\nPrefix\nType of Sequence\nSource\nDescription\n\n\n\n\nNM_\nmRNA\nCurated\nA manually reviewed and curated transcript (messenger RNA).\n\n\nNP_\nProtein\nCurated\nA protein sequence derived from an NM_ transcript.\n\n\nNC_\nGenomic DNA\nCurated\nA reference genomic contig or chromosome.\n\n\nNG_\nGenomic region\nCurated\nA curated genomic region (e.g., a gene with its regulatory elements).\n\n\nXM_\nmRNA\nPredicted (Model)\nA computationally predicted transcript (not manually reviewed).\n\n\nXP_\nProtein\nPredicted (Model)\nA protein sequence derived from an XM_ transcript.\n\n\n\n\nNM_ and NP_ always go together — NM_ is the transcript, NP_ is the corresponding protein.\nXM_ and XP_ serve the same function as NM_ and NP_, but are generated through computational predictions (often for less well-characterized organisms or isoforms).\nNC_ and NG_ are genomic-level references, where NC_ is often a whole chromosome and NG_ might cover a specific gene region with context.\n\n\n\nWhen we select our species, we want to choose NP_ sequences when possible over the predicted XP_ sequences. We will also choose the longest sequence available.\n\none_per_species &lt;- link_df %&gt;% \n  group_by(organism) %&gt;% \n  arrange(caption, desc(slen), .by_group = TRUE) %&gt;% \n  dplyr::slice(1)\n\nNow we have ids for 9 protein sequences, so we can retrieve them with entrez_fetch.\n\ntp53_fasta &lt;- entrez_fetch(db = \"protein\",\n                           id = one_per_species$uid , \n                           rettype = \"fasta\")\n\n\ncat(tp53_fasta)\n\nFinally, let’s save our sequences to a fasta file.\n\nwriteLines(tp53_fasta, \"data/tp53_orthologs.fasta\")"
  },
  {
    "objectID": "03-msa.html#pairwise-alignment",
    "href": "03-msa.html#pairwise-alignment",
    "title": "Building a Bioinformatics Workflow",
    "section": "Pairwise Alignment",
    "text": "Pairwise Alignment\nNow we can start to compare our sequences with each other. First let’s compare just two sequences.\nWe can use Biostrings again to import our fasta file. This time, since we’re working with proteins, we’ll use the function readAAStringSet()\nOur AAStringSet object now contains multiple sequences. We can access them with bracket notation.\n\northologs &lt;- readAAStringSet(\"data/tp53_orthologs.fasta\")\northologs[1] #look at first sequence\n\nAAStringSet object of length 1:\n    width seq                                               names               \n[1]   386 MEESQAELNVEPPLSQETFSDLW...SKKRPSPSCHKKPMLKREGPDSD NP_776626.1 cellu...\n\northologs[2] #look at second sequence\n\nAAStringSet object of length 1:\n    width seq                                               names               \n[1]   381 MQEPQSELNIDPPLSQETFSELW...AKKGQSTSRHKKLMFKREGPDSD NP_001376147.1 ce...\n\n\nOne thing that will make our analysis more readable is if we clean up the names for each sequence. The names are derived from the header row of each sequence in fasta format.\n\nnames(orthologs)\n\n[1] \"NP_776626.1 cellular tumor antigen p53 [Bos taurus]\"                    \n[2] \"NP_001376147.1 cellular tumor antigen p53 [Canis lupus familiaris]\"     \n[3] \"NP_001258749.1 cellular tumor antigen p53 isoform 1 [Danio rerio]\"      \n[4] \"NP_000537.3 cellular tumor antigen p53 isoform a [Homo sapiens]\"        \n[5] \"NP_001040616.1 cellular tumor antigen p53 [Macaca mulatta]\"             \n[6] \"NP_001120705.1 cellular tumor antigen p53 isoform b [Mus musculus]\"     \n[7] \"XP_001172077.2 cellular tumor antigen p53 isoform X2 [Pan troglodytes]\" \n[8] \"NP_001416922.1 cellular tumor antigen p53 isoform a [Rattus norvegicus]\"\n[9] \"NP_001001903.1 cellular tumor antigen p53 [Xenopus tropicalis]\"         \n\n\nWe can clean the names to get just the organism name. This will be useful later when we build our phylogenetic tree. To do this, we will use the stringr package from the tidyverse along with regular expressions. Regular expressions (or regex) are a concise language for describing patterns in strings.\n\n\n\n\n\n\nRegex metacharacters\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSymbol\nMeaning\nExample\nDescription\n\n\n\n\n\n\n.\nAny single character (except newline)\n\"a.b\" matches acb, arb\nDot matches any character\n\n\n\n\n*\n0 or more of the preceding item\n\"ab*c\" matches ac, abc, abbc\nMatches zero or more occurrences\n\n\n\n\n+\n1 or more of the preceding item\n\"ab+c\" matches abc, abbc but not ac\nMatches one or more occurrences\n\n\n\n\n?\n0 or 1 of the preceding item\n\"ab?c\" matches ac, abc\nMatches zero or one occurrence\n\n\n\n\n^\nStart of string\n\"^a\" matches apple but not banana\nAnchors the pattern to the beginning of the string\n\n\n\n\n$\nEnd of string\n\"e$\" matches apple but not elephant\nAnchors the pattern to the end of the string\n\n\n\n\n[]\nCharacter class\n\"[abc]\" matches a, b, or c\nMatches any one of the listed characters\n\n\n\n\n[^]\nNegated character class\n\"[^abc]\" matches any character except a, b, or c\nExcludes characters\n\n\n\n\n|\nAlternation (OR)\n\"cat|dog\" matches cat or dog\nMatches either the expression before or after the pipe\n\n\n\n\n()\nGrouping or capturing\n\"(ab)+\" matches abab\nGroups elements or captures for back-referencing\n\n\n\n\n{n}\nExactly n times\n\"a{3}\" matches aaa\nMatches exactly n repetitions\n\n\n\n\n{n,}\nAt least n times\n\"a{2,}\" matches aa, aaa, etc.\nMatches n or more repetitions\n\n\n\n\n{n,m}\nBetween n and m times\n\"a{2,4}\" matches aa, aaa, aaaa\nMatches between n and m repetitions\n\n\n\n\n\\\\\nEscape character\n\"\\\\.\" matches . literally\nEscapes special characters\n\n\n\n\n\nGreedy vs Lazy Quantifiers\n\n\n\n\n\n\n\n\n\nPattern\nDescription\nGreedy?\nExample Match\n\n\n\n\n.*\nAny character, 0+ times\nYes\nMatches from first &lt; to last &gt;\n\n\n.*?\nAny character, 0+ times\nNo\nMatches just &lt;tag&gt;\n\n\n.+\nAny character, 1+ times\nYes\nAs much as possible\n\n\n.+?\nAny character, 1+ times\nNo\nAs little as possible\n\n\n\n\n\n\n\nnames(orthologs) &lt;- names(orthologs) %&gt;% \n  str_extract(pattern = \"\\\\[.*?\\\\]\") %&gt;%   #extract all words enclosed in brackets\n  str_replace_all(pattern = \"\\\\[|\\\\]\", \n                  replacement = \"\") #remove brackets\n\nLet’s do a pairwise alignment of the first two sequences in our orthologs object using the pwalign package. We use a pairwise alignment to look for regions of similarity in our protein sequences.\n\nalign_hs_mm &lt;- \n  pwalign::pairwiseAlignment(orthologs[1], orthologs[2])\n\nTo summarize that alignment, we can get the percent identity with the pid() function.\n\npwalign::pid(align_hs_mm)\n\n[1] 79.79275"
  },
  {
    "objectID": "03-msa.html#multiple-sequence-alignment",
    "href": "03-msa.html#multiple-sequence-alignment",
    "title": "Building a Bioinformatics Workflow",
    "section": "Multiple Sequence Alignment",
    "text": "Multiple Sequence Alignment\nTo align all of our sequences, we’ll use the DECIPHER package to perform a multiple sequence alignment (MSA). There are several packages that can perform MSA (including the msa package). If we look at the documentation for the DECIPHER package AlignSeqs requires a XStringSet object. When we created our orthologs object with Biostings it created an AAStringSet, so we can easily use Biostrings and DECIPHER together for our analysis. This is how we start to build a bioinformatics workflow in R.\n\nmsa &lt;- AlignSeqs(orthologs)\n\nWe can view this more clearly in the browser.\n\nBrowseSeqs(msa)"
  },
  {
    "objectID": "03-msa.html#building-a-phylogenetic-tree",
    "href": "03-msa.html#building-a-phylogenetic-tree",
    "title": "Building a Bioinformatics Workflow",
    "section": "Building a Phylogenetic Tree",
    "text": "Building a Phylogenetic Tree\nNow that we have our alignment, we need to calculate a distance matrix. This will be used to construct our tree. DistanceMatrix() is another package from DECIPHER that requires an XStringSet object.\n\ndist &lt;- DistanceMatrix(msa)\n\n================================================================================\n\nTime difference of 0 secs\n\n\nThe ape package allows you to construct trees. We’ll use the Neighbor Joining algorithm.\n\ntree &lt;- nj(dist)\n\nFinally, we can plot our tree, using a variation of base Rplot(). plot.phylo() requires an object of class phylo, which we created\n\nplot.phylo(tree)\n\n\n\n\n\n\n\n\nThere are several ways you can customize your plot. Here are some examples:\n\n\n\n\n\n\n\n\nArgument\nDescription\nExample\n\n\n\n\ntype\nTree layout: \"phylogram\", \"cladogram\", \"fan\", \"unrooted\", \"radial\"\nplot(tree, type = \"fan\")\n\n\ndirection\nDirection: \"rightwards\", \"leftwards\", \"upwards\", \"downwards\"\nplot(tree, direction = \"downwards\")\n\n\nuse.edge.length\nUse branch lengths (TRUE) or equal lengths (FALSE)\nplot(tree, use.edge.length = FALSE)\n\n\nshow.tip.label\nShow/hide tip labels\nplot(tree, show.tip.label=FALSE)\n\n\ncex\nFont/label size\nplot(tree, cex=0.8)\n\n\nlabel.offset\nSpace between labels and tree\nplot(tree, label.offset=0.01)\n\n\nno.margin\nRemove plot margins\nplot(tree, no.margin=TRUE)\n\n\nedge.width\nLine thickness\nplot(tree, edge.width=2)\n\n\nedge.color\nColor of edges\nplot(tree, edge.color=\"blue\")\n\n\n\nWe can also use the title() function to add a title.\n\nplot.phylo(tree, \n           label.offset = 0.2,\n           direction = \"left\",\n           edge.width = 2,\n           edge.color = \"steelblue\",\n           font = 1,\n           use.edge.length = FALSE)\ntitle(main = \"TP53 Protein-Based Phylogeny of Selected Vertebrate Species\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCHALLENGE\n\n\n\nTry customizing your tree in various ways. Use the Help pane to look at documentation for plot.phylo() if necessary"
  },
  {
    "objectID": "01-GettingSetUp.html",
    "href": "01-GettingSetUp.html",
    "title": "Introduction and Set Up",
    "section": "",
    "text": "Understand the difference between CRAN and Bioconductor\nBe able to install Bioinformatics packages"
  },
  {
    "objectID": "01-GettingSetUp.html#learning-objectives",
    "href": "01-GettingSetUp.html#learning-objectives",
    "title": "Introduction and Set Up",
    "section": "",
    "text": "Understand the difference between CRAN and Bioconductor\nBe able to install Bioinformatics packages"
  },
  {
    "objectID": "01-GettingSetUp.html#getting-set-up",
    "href": "01-GettingSetUp.html#getting-set-up",
    "title": "Introduction and Set Up",
    "section": "Getting Set Up",
    "text": "Getting Set Up\nRStudio provides a useful feature called Projects which act like a container for your work. As you use R more, you will find it useful to make sure your files and environment for one real-world project are kept together and separate from other projects.\nLet’s create a new project now.\n\nGo to File &gt; New Project\nIn Create project from menu choose New Directory\nChoose Project Type New Project\nMake sure Create project as subdirectory of: is pointing to Desktop (or whatever your preferred location is)\nCall your new directory r_bioinformatics_lesson\nSelect the check box that says Open in New Session\nInside your new project, create folders called data and figures"
  },
  {
    "objectID": "01-GettingSetUp.html#what-is-bioconductor",
    "href": "01-GettingSetUp.html#what-is-bioconductor",
    "title": "Introduction and Set Up",
    "section": "What is Bioconductor?",
    "text": "What is Bioconductor?\nIn this lesson, we’ll be working with a number of bioinformatics packages along with the tidyverse family of packages. Many R packages come from CRAN (Comprehensive R Archive Network). Packages from CRAN can be installed either by using the Install Packages widget in RStudio (lower-right pane) or with the function install.packages().\nBioconductor is an open-source project that provides tools for the analysis and comprehension of high-throughput biological data, built on the R programming language. It includes a large ecosystem of packages for tasks such as sequence analysis, genomic data visualization, and statistical modeling in bioinformatics. Bioconductor emphasizes reproducibility, interoperability, and the integration of biological metadata, making it especially well-suited for omics research.\nTo use packages from Bioconductor, we must first install and load the Biocmanager package from CRAN. Biocmanager provides an interface to the Bioconductor repository.\n\nif (!requireNamespace(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\")\n\nlibrary(BiocManager)\n\nNext, let’s install the packages we will be using in this session. From CRAN, we’ll be installing\n\n\n\nPackage Name\nPurpose\n\n\n\n\ntidyverse\nWrangling and visualizing data\n\n\nrentrez\nAccessing data from NCBI databases\n\n\nape\nPhylogenetic analysis\n\n\n\n\ninstall.packages(c(\"tidyverse\", \"rentrez\", \"ape\"))\n\nThen we can install our Bioconductor packages with Biocmanager\n\n\n\nPackage Name\nPurpose\n\n\n\n\nBiostrings\nManipulating biological sequences\n\n\npwalign\nPairwise Alignment\n\n\nDECIPHER\nMultiple Sequence Alignment\n\n\n\n\nBiocManager::install(c(\"Biostrings\", \"pwalign\", \"DECIPHER\"))\n\nNOTE: You only need to install a package once on your system (and after updates), but you will want to load the packages into your R session with the library() function.\n\nlibrary(ape)\nlibrary(Biostrings)\nlibrary(DECIPHER)\nlibrary(pwalign)\nlibrary(rentrez)\nlibrary(tidyverse)\n\nDon’t be afraid if you see a lot of text and messages printing out in the console as you go through this process. You may be asked to update other packages that the ones we are trying to install are dependent on. You will also be warned if some of the packages have functions with the same name."
  },
  {
    "objectID": "02-rentrez.html",
    "href": "02-rentrez.html",
    "title": "Accessing and manipulating biological sequences",
    "section": "",
    "text": "Be able to name some main NCBI databases and their purposes\nBecome familiar with the rentrez core functions and how they are related.\nUnderstand how to programmatically access NCBI data.\nUse R to analyze and manipulate a biological sequence"
  },
  {
    "objectID": "02-rentrez.html#learning-objectives",
    "href": "02-rentrez.html#learning-objectives",
    "title": "Accessing and manipulating biological sequences",
    "section": "",
    "text": "Be able to name some main NCBI databases and their purposes\nBecome familiar with the rentrez core functions and how they are related.\nUnderstand how to programmatically access NCBI data.\nUse R to analyze and manipulate a biological sequence"
  },
  {
    "objectID": "02-rentrez.html#ncbi-data-and-the-rentrez-package",
    "href": "02-rentrez.html#ncbi-data-and-the-rentrez-package",
    "title": "Accessing and manipulating biological sequences",
    "section": "NCBI data and the rentrez package",
    "text": "NCBI data and the rentrez package\nThe National Center for Biotechnology Information (NCBI), a division of the National Library of Medicine, maintains several databases that provide access to a wide range of biological data and tools, including databases for DNA and protein sequences (GenBank, RefSeq), scientific literature (PubMed, PMC), and resources for analyzing genetic and genomic information (BLAST, Gene, SRA toolkit). It serves as a central hub for researchers around the world to find, share, and analyze biological data. NCBI is a major partner in the International Nucleotide Sequence Database Collaboration (INSDC) along with EMBL-EBI in Europe and DDBJ in Japan.\nEntrez is the name of the integrated search system across all NCBI databases. Programmatic access to the Entrez system is provided by the Entrez Programming Utilities (E-utilities). The E-utilities can be used on the command line, but in this class, we will be using the rentrez package, an R interface to the program.\nFirst, let’s see what databases we can access with rentrez\n\nentrez_dbs()\n\n [1] \"pubmed\"          \"protein\"         \"nuccore\"         \"ipg\"            \n [5] \"nucleotide\"      \"structure\"       \"genome\"          \"annotinfo\"      \n [9] \"assembly\"        \"bioproject\"      \"biosample\"       \"blastdbinfo\"    \n[13] \"books\"           \"cdd\"             \"clinvar\"         \"gap\"            \n[17] \"gapplus\"         \"grasp\"           \"dbvar\"           \"gene\"           \n[21] \"gds\"             \"geoprofiles\"     \"medgen\"          \"mesh\"           \n[25] \"nlmcatalog\"      \"omim\"            \"orgtrack\"        \"pmc\"            \n[29] \"proteinclusters\" \"pcassay\"         \"protfam\"         \"pccompound\"     \n[33] \"pcsubstance\"     \"seqannot\"        \"snp\"             \"sra\"            \n[37] \"taxonomy\"        \"biocollections\"  \"gtr\"            \n\n\nWe can also see what fields are available to search in a database\n\nentrez_db_searchable(db=\"gene\")\n\nSearchable fields for database 'gene'\n  ALL    All terms from all searchable fields \n  UID    Unique number assigned to a gene record \n  FILT   Limits the records \n  TITL   gene or protein name \n  WORD   Free text associated with record \n  ORGN   scientific and common names of organism \n  MDAT   The last date on which the record was updated \n  CHR    Chromosome number or numbers; also 'mitochondrial', 'unknown' properties \n  MV     Chromosomal map location as displayed in MapViewer \n  GENE   Symbol or symbols of the gene \n  ECNO   EC number for enzyme or CAS registry number \n  MIM    MIM number from OMIM \n  DIS    Name(s) of diseases associated with this gene. When available, OMIM name will be used \n  ACCN   Nucleotide or protein accession(s) associated with this gene \n  UGEN   UniGene cluster number for this gene \n  PROP   Properties of Gene record \n  CDAT   The date on which this record first appeared \n  NCAC   nucleotide accessions of sequences \n  NUID   nucleotide uids of sequences \n  PACC   protein accessions \n  PUID   protein uids \n  PMID   PubMed ids of accessions linked to the record \n  TID    taxonomy id \n  GO     Gene Ontology \n  DOM    Domain Name \n  DDAT   The date on which the record was discontinued \n  CPOS   Chromosome base position \n  GFN    Gene full name \n  PFN    Protein full name \n  GL     Gene length \n  XC     Exon count \n  GRP    Relationships for this gene \n  PREF   Preferred symbol of the gene \n  AACC   Assembly accession \n  ASM    Assembly name \n  EXPR   Gene expression \n\n\nThe functions of rentrez are designed to work together. The main ones we will be using in this session are:\n\n\n\n\n\n\n\nFunction\nPurpose\n\n\n\n\nentrez_search()\nSearch a specific NCBI database and retrieve UIDs (unique identifiers).\n\n\nentrez_summary()\nGet summary metadata for UIDs returned by a search.\n\n\nextract_from_esummary()\nExtract specific fields (e.g., title, publication date) from esummary results.\n\n\nentrez_fetch()\nDownload full records (e.g., FASTA, GenBank, XML).\n\n\nentrez_link()\nFind related data across NCBI databases.\n\n\n\nYou can check out the rentrez documentation for more information on these and other functions."
  },
  {
    "objectID": "02-rentrez.html#finding-and-fetching-a-sequence",
    "href": "02-rentrez.html#finding-and-fetching-a-sequence",
    "title": "Accessing and manipulating biological sequences",
    "section": "Finding and fetching a sequence",
    "text": "Finding and fetching a sequence\nLet’s start by searching for the record in the Gene database for human gene TP53, an important gene in the study of cancer. The entrez_search() function takes the following arguments:\n\ndb, name of the database to search for (required)\nterm, the search term, you can also use MeSH terms to perform your search (required)\nretmax, the default of retrievable ids is 20, this argument can be used to change that number\nretmode, to select the format of your output (XML or JSON), by default will be XML\nuse_history, to store a history of searches in NCBI’s server\n\nThe term argument can take a simple or more complicated search string linked together with boolean terms AND, OR, and NOT. The name of the field like [gene name] or [orgn] comes after the search term for that field. Note that the [orgn] field can accept scientific or common names or organisms.\n\nsearch_tp53_hs &lt;- entrez_search(db=\"gene\", \n                                term =\"TP53[gene] AND human[orgn]\")\n\n\n\n\n\n\n\nLists\n\n\n\nLet’s take a closer look at the results we get from our search. The search_tp53_hs object is a structure called a list. Recall that a vector is a one-dimensional data structure in R where every element must be of the same type. Lists are one-dimensional data structures where elements can be anything, even data frames or other lists. Lists are a common way to store hierarchical data, like XML or JSON data formats. You’ll find that it is very common for data to be stored as a list in bioinformatics workflows.\n\n\n\n\n\n\n\n\n\nHomogeneous\nHeterogeneous\n\n\n\n\n1D\nVectorAll elements of the same type\nListCan contain any type of R object\n\n\n2D\nMatrixAll elements of the same type\nData FrameEach column can differ in type\n\n\n\nTo access items in a list, you can use $ or [[]], similar to accessing vectors in a dataframe. There are five elements in our search object:\n\n\n\n\n\n\n\nElement\nDescription\n\n\n\n\ncount\nTotal number of records in the database that match the search query.\n\n\nretmax\nThe number of IDs returned in the ids vector (default is 20, can be changed).\n\n\nids\nA character vector of NCBI record IDs that matched the search.\n\n\nQueryTranslation\nShows how NCBI interpreted and expanded your search query using synonyms etc.\n\n\nfile\nA temporary file storing your search results (used internally by rentrez).\n\n\n\nWe can look closer at the ids element:\n\nsearch_tp53_hs$ids\n\n[1] \"7157\"\n\n\nor\n\nsearch_tp53_hs[[1]]\n\n[1] \"7157\"\n\n\n\n\nThe ids will likely be the most important part of the search object. You can use those ids with entrez_summary(), entrez_link() and entrez_fetch().\nLet’s use the id to see if there are records for human TP53 in the nucleotide database. While Gene contains metadata about genes, nucleotide contains the actual sequences. There are three main arguments you need to supply to the link function:\n\ndbfrom character name of database from which the id(s) originate\nids vector with unique ID(s) for records in database db\ndb character name of database in which to search for links. Use “all” to search for links in all databases.\n\nSo we are going to search from gene with the id we retrieved from our search, and look in “nuccore”, the name for nucleotide in the Entrez system.\n\nlink_tp53_hs &lt;- entrez_link(dbfrom=\"gene\", \n                            id=search_tp53_hs$ids, \n                            db=\"nuccore\")\n\nLet’s take a closer look at the links element of our link object\n\nlink_tp53_hs$links\n\nelink result with information from 4 databases:\n[1] gene_nuccore            gene_nuccore_mgc        gene_nuccore_refseqgene\n[4] gene_nuccore_refseqrna \n\n\nThis is saying there are related records for this gene in the general nucleotide collection, as well as in three subsets: Mammalian Gene Collection, RefSeqGene and RefSeqRNA. We will be especially interested in the RefSeqGene sequence. RefSeq, short for Reference Sequence, is NCBI’s curated collection of consensus sequences. These are likely to be higher quality than other sequences, so it is a good idea to use them for your analysis when possible.\nWe can access the RefSeqGene id:\n\nlink_tp53_hs$links$gene_nuccore_refseqgene\n\n[1] \"383209646\"\n\n\nNow we have the id for the sequence we want to look at, we use entrez_fetch(), which requires three arguments\n\ndb character name of the database to use\nid vector of unique ID(s) for records in database db\nrettype - character name of the format in which to return record, such as fasta or xml. We will ask for our record in fasta format, a common plain text way of representing sequence data.\n\n\nfetch_tp53_hs &lt;- entrez_fetch(db=\"nuccore\",\n                              id=link_tp53_hs$links$gene_nuccore_refseqgene, \n                              rettype = \"fasta\")\n\nNow let’s take a look at our sequence in the console. You can see it’s pretty simple, just a header line starting with &gt; and the sequence of bases.\nWhen we print it to the console as usual, we see a lot of \\n characters which is the newline symbol.\n\nfetch_tp53_hs\n\nWe can use the cat function to print it out a little more nicely.\n\ncat(fetch_tp53_hs)\n\nWe can also save this to a file\n\nwriteLines(fetch_tp53_hs, \"data/tp53_human.fasta\")\n\n\nTry it Yourself!\n\n\n\n\n\n\nCHALLENGE\n\n\n\n\nLook up which fields are searchable in the Protein database.\nSearch Gene for the BRCA1 gene in humans. What id is returned?\nUse entrez_link() to find all databases that have a link to this Gene record. How many databases are linked? How many related records are there in Pubmed?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nentrez_db_searchable(\"protein\")\nbrca1_search &lt;- entrez_search(db = \"gene\", term = \"BRCA1[gene] AND human[orgn]\")  brca1_search$ids\nbrca1_link &lt;- entrez_link(dbfrom = \"gene\", id = test_search$ids, db = \"all\") brca1_link$links brca1_links$links$gene_pubmed"
  },
  {
    "objectID": "02-rentrez.html#manipulating-sequences-with-biostrings",
    "href": "02-rentrez.html#manipulating-sequences-with-biostrings",
    "title": "Accessing and manipulating biological sequences",
    "section": "Manipulating sequences with Biostrings",
    "text": "Manipulating sequences with Biostrings\nNow we will use the Biostrings package from Bioconductor to read in our fasta file and save it as the specialized class XStringSet which essentially serves as a container sets of biological sequence data. The X can be replaced by the appropriate molecule: DNA, RNA, or AA for proteins. So here we are saving our object as a DNAStringSet\n\nfasta &lt;- readDNAStringSet(\"data/tp53_human.fasta\")\n\nXStringSets are made up of XString objects. That is, each sequence in a XStringSet is a XString object. Even though our fasta file only contains one sequence, we still save it as an DNAStringSet. We can specifically pull out our sequence into a DNAStringSet object.\n\ndna_tp53_human &lt;- fasta[[1]]\n\nAs you work more with bioinformatics packages, you’ll find that many of them create these kinds of specialized classes, and you’ll be able to put together workflows of packages designed to work with each other’s data structures.\nNow we have our DNAString object, we can use BioStrings to get summary statistics and manipulate it to other objects.\nFirst we can use alphabetFrequency to get the frequence of bases in our sequence.\n\nalphabetFrequency(dna_tp53_human)\n\n   A    C    G    T    M    R    W    S    Y    K    V    H    D    B    N    - \n8647 7986 8058 8081    0    0    0    0    0    0    0    0    0    0    0    0 \n   +    . \n   0    0 \n\n\nIn addition to the four bases ACGT, it also contains several other codes that indicate ambiguous bases. This is a high quality consensus RefSeq sequence though, so we do not have any ambiguous bases.\nWe can specify we are only interested in ACGT counts by specifying the argument baseOnly = TRUE\n\nalphabetFrequency(dna_tp53_human, baseOnly = TRUE)\n\n    A     C     G     T other \n 8647  7986  8058  8081     0 \n\n\nTo look for a specific base or base, we can use letterFrequency instead of alphabetFrequency:\n\ngc_content &lt;- letterFrequency(dna_tp53_human, \n                              letters = c(\"G\", \"C\"), \n                              as.prob=TRUE)\nsum(gc_content)\n\n[1] 0.4895643\n\n\nWe can also use Biostrings to generate the complement of the DNA strand, the reverse, and the reverse complement.\n\ntp53_comp &lt;- complement(dna_tp53_human)\ntp53_rev &lt;- reverse(dna_tp53_human)\ntp53_rev_comp &lt;- reverseComplement(dna_tp53_human)\n\nLet’s compare:\n\ndna_tp53_human\ntp53_comp\ntp53_rev\ntp53_rev_comp\n\n32772-letter DNAString object\nseq: CTCCTTGGTTCAAGTAATTCTCCTGCCTCAGACTCC...AAAAAAAAGATACTACAAAGTCAAGAGACAAACAAT\n32772-letter DNAString object\nseq: GAGGAACCAAGTTCATTAAGAGGACGGAGTCTGAGG...TTTTTTTTCTATGATGTTTCAGTTCTCTGTTTGTTA\n32772-letter DNAString object\nseq: TAACAAACAGAGAACTGAAACATCATAGAAAAAAAA...CCTCAGACTCCGTCCTCTTAATGAACTTGGTTCCTC\n32772-letter DNAString object\nseq: ATTGTTTGTCTCTTGACTTTGTAGTATCTTTTTTTT...GGAGTCTGAGGCAGGAGAATTACTTGAACCAAGGAG"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  }
]